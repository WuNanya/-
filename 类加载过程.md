### 基础要点
1. 字节码.class文件加载到内存中，才可以实例化类
2. ClassLoader负责提前加载.class类文件到内存中
3. 加载类使用双亲委派模型(溯源委派加载模型)，后文会提到
### 类加载步骤
1. **Load(加载)**
    - 读取类文件，产生二进制流 -> 特定数据结构
    - 校验魔法数、常量池、文件长度、是否有父类
    - 创建对应类的java.lang.Class实例(表示这个类的类型信息)
2. **Link(链接)**
    - **验证**：更详细的校验 比如:final是否合规等
    - **准备**：为静态变量分配内存，并设定默认值
    - **解析**：确保类与类之间引用正确，完成内存布局
3. **Init(初始化)**
    - 执行构造器<clinit>方法，如果赋值是通过其他类的静态方法完成的，那么会马上去解析另一个类

### Class 与 class
- 类加载是将.class字节码文件实例化成Class对象并进行相关的初始化
- class是关键字，用来定义类
- Class是所有class的类

### 类加载器如何定位到具体的类文件并读取？
- JVM在启动时会创建最根基的类加载器:Bootstrap,装载最核心的java类，如String、System等
- 第二层是在**JDK9**版本中，为Platform ClassLoader 即平台类加载器，用来加载扩展的系统类,如XML、加密的功能类，JDK9之前用的是Extension ClassLoader
- 第三层是Application ClassLoader的应用类加载器，主要加载用户定义的CLASSPATH路径下的类

### 双亲委派模型的类加载原则
- 低层次的类加载器，不能覆盖高层次类加载器已经加载的类
- 如果低层次的类加载器想加载一个未知类：
    - 第一步：询问高层次类加载器是否已经加载？
    - 第二步：高层次类加载器问自己是否已经加载了该类，如果没有就再询问自己是否可以加载
    - 第三步：如果高层次类加载器没有加载，也不能加载
    - 第四步：则会通知发起请求加载的类加载器，准予加载