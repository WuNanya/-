### 线程安全
>定义: 线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时的环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其它的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象的线程就是安全的。

- 按“安全程度”由强至弱排序分为五类：
    - 不可变
        - 不可变的对象一定是安全的，即用final关键字修饰的变量和对象一定是安全的，如String类中的substring()方法
    - 绝对线程安全
        - 绝对线程安全满足线程安全的定义，即java中声明了线程安全的类，如果Vector就是一个线程安全的容器，他的的add()等方法都是被synchronsized修饰的。 
    - 相对线程安全
        -   需要保证对这个对象单独操作是线程安全的
        -   在java中如Vector，HashTable等
    - 线程兼容
        - 指线程本身并不安全，但是可以通过调用正确的同步手段来保证并发环境中可以安全的使用
    - 线程对立
        - 不论采用什么手段都不安全，并不常见

### 线程安全的实现方法
1. **互斥同步**
- 定义：互斥同步是常见的一种并发正确性保障手段
- 注意：互斥是因，同步是果；互斥是方法，同步是目的
- 方法：synchronized关键字，java.util.concurrent包中的重入锁ReentrantLock来实现同步
- **synchronized关键字**
    - 在字节码前后分别形成monitorenter和monitorexit两个两个字节码指令
    - **执行流程：**
         - 执行monitorenter指令时，尝试获取对象的锁，如果对象没被锁定，或者该线程已经持有了那个对象的锁，锁计数器就加一，当执行到monitorexit时，锁计数器就减一，当计数器为0时，锁就被释放，如果获取对象失败，当前线程就要**阻塞等待**，直到线程锁被释放。
     - **注意点：**
        - synchronzied同步块对于一条线程是可重入的，不不会出现自己把自己锁死。
        - 由于java的线程是映射到操作系统原生线程上的，所以**阻塞和唤醒**线程都会涉及到**用户态和核心态**之间的转换，因此资源的消耗非常大，被**称为为重量级锁**
- **ReentrantLock(java.util.concurrent)**
    - 区别：ReentrantLock表现为**API层面的锁**，运用Lock和unLock方法配合try和finally语句来完成，而synchronzied表现为**原生语法**层面的锁
    - 特点：
   1. **等待可中断**
    - 持有锁的线程长期不释放锁的时候，正在等待的线程可以放弃等待去干其它的事情(重要)
    2. **公平锁**
    - 根据申请锁的时间顺序来依次获得锁
    3. **锁绑定多个条件**
    - 一个ReentrantLock对象可以同时绑定多个条件对象
2. 非阻塞同步
- 乐观策略
- 步骤：进行操作和冲突检测需要具备原子性，需要靠硬件来保证原子性

3. 无同步方案
- 线程本地存储：尝试将共享数据的代码保证在同一个线程中执行，因此无须同步也能保证线程之间不出现数据争用的问题
    
### 锁优化
1.1. **自旋锁与自适应自旋**
- 前提: 互斥同步需要通过阻塞实现，而挂起线程和恢复线程都需要转入内核态实现，而内核态和用户态的转换需要消耗很多处理器的时间，同时共享数据的锁定状态只需要很短的一段时间，阻塞线程的两太转换需要消耗太长时间，不值得，由此提出了自旋锁。
- 方案：让后面请求锁的线程稍等一下，但不放弃处理器资源，即线程执行一个忙循环，这就是自旋锁。
- 特点：如果锁被占用的时间比较短，自旋等待的效果就很好，如果锁被占用的时间长，如果锁被占用的时间长，就会浪费很多处理器资源。
- 优化方案：给自旋等待时间设置一定的限度，如果自旋次数超过了一定限度还没有获得锁，就将该线程挂起（自旋默认10次）
1.2 **自适应自旋**
- 思想：由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定
- 例如：如果自旋等待刚刚成功了，就会认为下次又会成功，因此允许自选等待持续相对长的时间，如果总是失败，就直接挂起线程
2. **锁清除**
- 定义：虚拟机即时编译器在运行时，对一些代码上要求同步，如果检测到了不可能出现数据竞争的线程，就会对其锁进行消除 
3. **锁粗化**
- 定义：一系列连续操作对同一个对象反复加锁解锁，或加锁操作出现在循环体中，就会频繁的加锁解锁，出现性能的巨大损耗，因此通过扩大锁的粒度，只需要加一次锁就能解决问题。
4. **轻量级锁**
5. **偏向锁**