### JVM的内存布局
1. 本地方法栈(Native Method Stacks)
2. 程序计数器(Program Counter Register)
3. 虚拟机栈(JVM Stacks)
4. 堆区(Heap)
5. 元数据区(Metaspace)
6. JIT编译产物(CodeCache)

### Heap(堆区) 
- **基本概念**
- Heap是OOM故障的主要发源地，存储着几乎所有的实例对象。
- 堆区由垃圾回收器自动回收，由子线程共享使用。
- 在生产环境中，JVM的Xms和Xmx设置成一样大小，避免在堆的动态调整中带来额外的压力（Xms和Xmx代表最小堆容量和最大堆容量）
- **堆的结构**
- 分为两大块：新生代和老年代
- 老年代也接纳新生代无法容纳的超大对象
- 新生代 = 1个Eden区 + 2个Survivor区 Eden区和survivor区的比例为8：1的关系。
- Eden区填满之后会触发YGC(young garbage collection),并且将存活的对象转移到survivor中，survivor区又分为s0和s1两块，会将存活的对象复制到未使用的那块空间，然后将死了的对象全部清楚，交换两块空间的状态。
- 当移交的对象大于Survivo时 直接送到老年代。
- 每个对象都有一个计数器，因为有的对象会在Survivor的两块区中换来换去，设置一个计数器默认值是15，交换14次之后就会进入老年代
- 如果Survivo区放不下，老年代也放不，则会进行FGC(Full Garbage Collection)
- 如果还不放下，则抛出OOM


### Metaspace(元空间)
- 在JDK7及以前的版本中，只有Hotspot才有Perm区，译为永久代，它的大小是固定的，很难进行调优。有的时候动态类加载的过多就会导致Perm区的OOM。
- Perm区中的所有内容中字符串常量移至堆内存，其他内容包括类元信息、字段、静态属性、方法、常量等都移动到元空间内。

### JVM Stack(虚拟机栈)
- JVM中的虚拟机栈是描述java方法执行的内存区域，它是线程私有的
- 栈帧是方法运行的基本结构
- 通过压栈出栈的方式，对每个方法对应的栈帧进行运算处理，正常结束就会跳到另一个栈帧上，如果出现异常，则会进行异常回溯，返回地址通过异常表确定。
- 栈帧包括局部变量表，操作栈，动态连接，方法返回地址
    - 局部变量表
        - 存放方法参数和局部变量的区域
    - 操作栈
        - 操作栈是一个初始状态为空的桶式栈结构，会将局部变量取出来放在操作栈中，进行出栈相加，再放回局部变量表
        - 某些指令可以直接在局部变量表中操作，如iinc指令，可以直接进行+1操作，不进行入栈
    - 动态连接
        - 每个栈帧中包含一个在常量池中对方法的引用，目的是支持方法调用过程中的动态连接
    - 方法返回地址
        - 方法执行的两种情况：第一是正常退出，第二是异常退出
        - 方法退出的三种方式:
            - 返回值压入上层调用栈帧
            - 异常信息抛给能够处理的栈帧
            - PC计数器指向方法调用后的下一条指令
- 本地方法栈
    - 线程私有的
    - 本地方法栈是为Native服务的
    - 调用本地方法时，不再受JVM的约束。
    - 本地方法可以通过Java Nativ Interface(JNI)来访问虚拟机运行时的数据区，甚至还可以调用寄存器，有和jvm一样的权限
    - 会削弱jvm的系统控制力
- 程序计数器
    - 程序计数器存放执行指令的偏移量和行号指示器等
    - 线程恢复和执行都要依赖它
    - 在各线程之间互不影响，每个线程都有一个。

### 总结
- 线程共享角度
- 堆和元空间是所有线程共享的
- 虚拟机栈、本地方法栈、程序计数器是线程私有的